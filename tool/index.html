<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Artificial Blood Diagram</title>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
  </head>

  <body>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <!-- touch-action="none" for best results from PEP -->

    <script>


// below is the default babylon playground code automatically established in every canvas


      const canvas = document.getElementById("renderCanvas"); // Get the canvas element
      const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

      // Add your code here matching the playground format
      const createScene = function () {
        const scene = new BABYLON.Scene(engine);

        // BABYLON.ImportMeshAsync("https://assets.babylonjs.com/meshes/box.babylon");

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
        camera.attachControl(canvas, true);
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));


        return scene;
      };

      const scene = createScene(); //Call the createScene function

      // Register a render loop to repeatedly render the scene
      engine.runRenderLoop(function () {
        scene.render();
      });

      // Watch for browser/canvas resize events
      window.addEventListener("resize", function () {
        engine.resize();
      });



// below is the code we conjoined from varied demos and tutorial videos




      // func to create blood machine
      function createBloodMachine() {
          const machineGroup = new BABYLON.TransformNode("machineGroup", scene); // a node in babylon can hold other nodes and is equivalent to a parent and child in regular code by managing code under the node which includes aspects like position, rotation, scale, etc. This specific node is named machineGroup and it will serve as parent for all machine components, allowing for multiple transformations to happen at once when reffering to it

          // create machine components
          const components = [ // array named components containing shape type, params, and position, essentially making a list of customizables we can choose from to draw our model
              { type: 'base', params: { height: 0.5, width: 2, depth: 2 }, position: new BABYLON.Vector3(0, 0.25, 0) }, // "new BABYLON.Vector3" was a commonly associated babylon type associated with positions in several babylon demos making it necessary to make the position function, we would encounter more varities of these types for different babylon parameteres throughout the proj.
              { type: 'cylinder', params: { height: 3, diameter: 0.5 }, position: new BABYLON.Vector3(0, 2, 0) },
              { type: 'cylinder', params: { height: 1, diameter: 0.5 }, position: new BABYLON.Vector3(1, 1.5, 0) },
              { type: 'sphere', params: { diameter: 1 }, position: new BABYLON.Vector3(0, 3, 0) },
              { type: 'cylinder', params: { height: 2, diameter: 0.3 }, position: new BABYLON.Vector3(-1, 1, 0) }
          ];

          components.forEach(component => createComponent(component, machineGroup)); // forEach loop established to iterate over each component

          // add six small outer spheres of different colors to represent bloood comps.
          const colors = [
            // BABYLON.Color3 was another babylon type we found associated with the color element in babylon demos
              new BABYLON.Color3(1, 0, 0), // red, red blood cells
              new BABYLON.Color3(0, 1, 0), // green, plasma
              new BABYLON.Color3(0, 0, 1), // blue, white blood cells
              new BABYLON.Color3(1, 1, 0), // yellow, platelets
              new BABYLON.Color3(1, 0, 1), // magenta, conc.
              new BABYLON.Color3(0, 1, 1)  // cyan, other
          ];

          colors.forEach((color, index) => {
              const position = new BABYLON.Vector3(Math.cos(index * Math.PI / 3) * 3, 0.5, Math.sin(index * Math.PI / 3) * 3);
              createSphere("outerSphere" + index, 0.5, position, machineGroup, color);
              addTextToSphere("Sphere " + (index + 1), position, machineGroup);
          });

          // Add mouse hover effect
          addMouseHoverEffect(machineGroup);
      }

      // Helper function to create a component
      function createComponent(component, parent) {
          switch (component.type) {
              case 'base':
                  createBase(parent, component.params, component.position);
                  break;
              case 'cylinder':
                  createCylinder("cylinder" + Math.random(), component.params.height, component.params.diameter, component.position, parent);
                  break;
              case 'sphere':
                  createSphere("sphere" + Math.random(), component.params.diameter, component.position, parent);
                  break;
          }
      }

      // Helper function to create the base
      function createBase(parent, { height, width, depth }, position) {
          const base = BABYLON.MeshBuilder.CreateBox("base", { height, width, depth }, scene);
          base.position = position; // Set the position of the base
          base.parent = parent; // Set the parent to the machine group
          base.material = new BABYLON.StandardMaterial("baseMaterial", scene);
          base.material.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5); // Gray color
          return base; // Return the created base
      }

      // Helper function to create a cylinder with color
      function createCylinder(name, height, diameter, position, parent) {
          const cylinder = BABYLON.MeshBuilder.CreateCylinder(name, { height, diameterTop: diameter, diameterBottom: diameter }, scene);
          cylinder.position = position; // Set the position of the cylinder
          cylinder.parent = parent; // Set the parent to the machine group
          cylinder.material = new BABYLON.StandardMaterial(name + "Material", scene);
          cylinder.material.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.8); // Blue color
          return cylinder; // Return the created cylinder
      }

      // Helper function to create a sphere with color
      function createSphere(name, diameter, position, parent, color) {
          const sphere = BABYLON.MeshBuilder.CreateSphere(name, { diameter }, scene);
          sphere.position = position; // Set the position of the sphere
          sphere.parent = parent; // Set the parent to the machine group
          sphere.material = new BABYLON.StandardMaterial(name + "Material", scene);
          sphere.material.diffuseColor = color || new BABYLON.Color3(0, 50, 20); // Default to orange if no color is provided
          return sphere; // Return the created sphere
      }

      // Helper function to add text to a sphere
      function addTextToSphere(text, position, parent) {
          const dynamicTexture = new BABYLON.DynamicTexture("dynamicTexture", 512, scene, true);
          dynamicTexture.drawText(text, null, 250, "bold 44px Arial", "white", "transparent");

          const plane = BABYLON.MeshBuilder.CreatePlane("textPlane", { size: 1 }, scene);
          plane.material = new BABYLON.StandardMaterial("textMaterial", scene);
          plane.material.diffuseTexture = dynamicTexture;
          plane.position = position.add(new BABYLON.Vector3(0, 0.5, 0)); // Position above the sphere
          plane.parent = parent; // Set the parent to the machine group
      }

      // Function to add mouse hover effect
      function addMouseHoverEffect(parent) {
          parent.getChildren().forEach(child => {
              child.actionManager = new BABYLON.ActionManager(scene);

              // Store the original color
              const originalColor = child.material.diffuseColor.clone();

              // Register action for mouse over
              child.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, function() {
                  child.material.diffuseColor = new BABYLON.Color3(1, 0, 0); // Change to red on hover
              }));

              // Register action for mouse out
              child.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, function() {
                  child.material.diffuseColor = originalColor; // Reset to original color
              }));
          });
      }


      // Create the complex machine
      createBloodMachine();

      // Render loop
      engine.runRenderLoop(() => {
          scene.render(); // Continuously render the scene
      });



    </script>
  </body>
</html>
